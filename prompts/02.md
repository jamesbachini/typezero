## Task 2/5 — Implement Soroban leaderboard contract + unit tests (proof verification STUB)

**You are Codex. Implement this task fully before moving on. Run tests and fix errors.**

### Goal

Create Soroban contract `leaderboard` per `docs/spec.md`, but **stub proof verification** for now. Store player names and show them on leaderboard. No funds/prizes.

### Contract behaviour

* Network: Stellar **TESTNET**
* Maintain:

  * `CURRENT_CHALLENGE_ID -> u32`
  * `CHALLENGE_PROMPT_HASH(challenge_id) -> BytesN<32>`
  * Per-player best: `BEST(challenge_id, player) -> ScoreEntry`
  * Top N list (N=20): `TOP(challenge_id) -> Vec<LeaderboardRow>`

### Types

* `ScoreEntry { score:u64, wpm_x100:u32, accuracy_bps:u32, duration_ms:u32, name:String, submitted_ledger:u32 }`
* `LeaderboardRow { player:Address, name:String, score:u64, wpm_x100:u32, accuracy_bps:u32 }`

### Methods (required)

* `init(admin: Address, verifier_id: Address, image_id: BytesN<32>)`
* `set_challenge(admin-only): (challenge_id, prompt_hash)`
* `set_current_challenge(admin-only): (challenge_id)`
* `get_current_challenge() -> (challenge_id, prompt_hash)`
* `get_best(challenge_id, player) -> Option<ScoreEntry>`
* `get_top(challenge_id) -> Vec<LeaderboardRow>`
* `submit_score(...)` with args:

  * `challenge_id: u32`
  * `player: Address` (must equal invoker)
  * `name: String` (validate length 1..24; ASCII printable)
  * `prompt_hash: BytesN<32>` must match stored challenge
  * `score: u64, wpm_x100: u32, accuracy_bps: u32, duration_ms: u32`
  * proof placeholders: `journal_hash: BytesN<32>, image_id: BytesN<32>, seal: Bytes`
* Proof verify stub:

  * `fn verify_proof_stub(...) -> bool { true }`
  * keep the interface so Task 5 can swap to real verifier call

### submit_score logic

1. `require(player == invoker)`
2. `require(prompt_hash == stored prompt hash for challenge_id)`
3. `require(challenge_id == CURRENT_CHALLENGE_ID)` (for simplicity)
4. `require(image_id == stored IMAGE_ID)` (still check this)
5. stub verify returns true
6. Update per-player best if higher score
7. Update top list (insert/update, sort desc by score, truncate 20)
8. Persist `name` with the best score and top list row

### Unit tests (must implement)

* admin-only checks
* rejects: wrong invoker, wrong prompt hash, wrong challenge id, invalid name
* best-score update: higher replaces, lower ignored
* top list:

  * insert up to 20
  * 21st only inserted if score beats min
  * update existing player with improved score re-sorts
  * deterministic ordering on ties (e.g., by Address bytes)

### Commands you MUST run

* `cargo test` in `contracts/leaderboard`

### Output

Print:

* method signatures
* how to deploy on testnet (CLI commands in README, but don’t assume secrets)
